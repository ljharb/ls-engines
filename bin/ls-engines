#!/usr/bin/env node

'use strict';

const path = require('path');
const Semver = require('semver');
const { exec } = require('child_process');
const { default: intersect } = require('fast_array_intersect');
const chalk = require('chalk');
const yargs = require('yargs');
const allSettled = require('promise.allsettled');
const jsonFile = require('json-file-plus');
const fromEntries = require('object.fromentries');
<<<<<<< HEAD

=======
<<<<<<< HEAD
=======
const listify = require('listify');

>>>>>>> 9aa5bd5... wip with conflicts
>>>>>>> dd05eb2... wip with conflicts
const EXITS = require('../exit-codes');
const table = require('../table');
const getLatestEngineMajors = require('../getLatestEngineMajors');
const checkCurrent = require('../checkCurrent');
const checkEngines = require('../checkEngines');

const FALSE = Object(false);
const TRUE = Object(true);
<<<<<<< HEAD

=======
<<<<<<< HEAD
=======

const validEngines = ['node', 'npm'];

<<<<<<< HEAD
=======
>>>>>>> 9aa5bd5... wip with conflicts
>>>>>>> dd05eb2... wip with conflicts
>>>>>>> 6989428... wip with conflicts
const { argv } = yargs
	.option('mode', {
		choices: ['auto', 'actual', 'virtual', 'ideal'],
		default: 'auto',
		describe: `”actual“ reads from \`${chalk.gray('node_modules')}\`; ”virtual“ reads from a lockfile; “ideal” reads from \`${chalk.gray('package.json')}\``,
	})
	.option('engine', {
		coerce(arg) {
			arg.sort();
			const set = new Set(arg);
			if (set.size !== arg.length) {
				throw '”engines“ list must not contain duplicates';
			}
			if (arg.filter((x) => !validEngines.includes(c)) {
				throw `”engine” may only be: ${listify(validEngines.map(x => `"${x}"`))}`;
			}
			return set;
		},
		default: ['node', 'npm'],
		describe: 'Select which engine(s) to regard',
		type: 'array',
	})
	.option('production', {
		default: TRUE,
		describe: 'whether to include production deps or not',
		type: 'boolean',
	})
	.option('dev', {
		default: FALSE,
		describe: 'whether to include dev deps or not',
		type: 'boolean',
	})
	.option('save', {
		default: false,
		describe: `update \`${chalk.gray('package.json')}\`’s “engines” field to match that of your dependency graph`,
		type: 'boolean',
	})
	.option('current', {
		default: true,
<<<<<<< HEAD
		describe: 'check that the current engine version(s) matches your dependency graph’s requirements',
=======
		describe: 'check that the current engine version matches your dependency graph’s requirements',
>>>>>>> 433290c... wip with conflicts
		type: 'boolean',
	})
	.check(({ dev, production }) => {
		if (typeof dev === 'boolean' && typeof production === 'boolean') {
			// both arguments were explicitly passed
			if (!dev && !production) {
				// eslint-disable-next-line no-throw-literal
				throw 'One of `--dev` and `--production` must be enabled.';
			}
		}
		return true;
	})
	.option('engines', {
		choices: validEngines,
		default: validEngines,
		describe: 'which engine(s) to list',
		hidden: validEngines.length < 2,
		type: 'array',
	})
	.strict()
	.help();

function normalize(args) {
	let { dev, production, engines: originalEngines } = args;
	if (typeof dev === 'object' && typeof production === 'object') {
		// neither argument was explicitly passed
		dev = false;
		production = true;
	} else if (typeof dev === 'boolean' && typeof production === 'object') {
		// explicitly passed dev/no-dev, did not mention prod
		production = !dev || Boolean.prototype.valueOf.call(production);
	} else if (typeof dev === 'object' && typeof production === 'boolean') {
		// explicitly passed production/no-production, did not mention dev
		dev = !production || Boolean.prototype.valueOf.call(dev);
	}
	const selectedEnginesSet = new Set(originalEngines);
	const engines = validEngines.filter((engine) => selectedEnginesSet.has(engine));
	return { ...args, dev, engines, production };
}
<<<<<<< HEAD
const { current, dev, mode, production, save, engines: selectedEngines } = normalize(argv);
=======

const selectedEngines = ['node'];

const {
	current,
	dev,
	engine: selectedEngines,
	mode,
	production,
	save,
} = normalize(argv);
>>>>>>> 6989428... wip with conflicts

const getTree = require('../get-tree');
const getNodeVersions = require('../get-node-versions');
const getNPMVersions = require('../get-npm-versions');

const pPackage = jsonFile(path.join(process.cwd(), 'package.json'));

function keepTruthyNonStars(obj) {
	return fromEntries(Object.entries(obj).filter(([val]) => val && val !== '*'));
}

const pGraphEntries = getTree(mode, { dev, production }).then(async (tree) => {
	const nodesWithEngines = tree.inventory.filter(({
		package: {
			_inBundle,
			engines,
		},
<<<<<<< HEAD
	}) => !_inBundle && engines && validEngines.some((engine) => engines[engine]));
	const tuples = Array.from(
=======
	}) => !_inBundle && engines && engines.node);
	return Array.from(
>>>>>>> 6989428... wip with conflicts
		nodesWithEngines,
		({ name, package: { engines } }) => [name, keepTruthyNonStars(engines)],
	);
<<<<<<< HEAD
	return tuples.filter(([, engines]) => engines && validEngines.some((engine) => engines[engine] !== '*'));
=======
>>>>>>> 6989428... wip with conflicts
});

function caret(ver) {
	return '^' + ver.replace(/^v/g, '');
}

const pAllVersions = Promise.all([
	getNodeVersions(),
	getNPMVersions(),
]).then(([node, npm]) => ({ node, npm }));

async function checkCurrent(rootValids, graphValids) {
	let anyInvalid = false;
	const rows = await Promise.all(selectedEngines.map(async (engine) => {
		const currentVersion = await currentVersions[engine];
		const rootValid = rootValids[engine].includes(currentVersion);
		const graphValid = graphValids[engine].includes(currentVersion);
		if (!rootValid || !graphValid) {
			anyInvalid = true;
		}
		return [
			chalk.blue(engine),
			`${chalk.blue(chalk.bold(currentVersion))}`,
			`${chalk.bold(rootValid ? chalk.greenBright('yes') : chalk.red('no'))}!`,
			`${chalk.bold(graphValids ? chalk.greenBright('yes') : chalk.red('no'))}!`,
		];
	}));
	const output = [
		'',
		table([
			[
				'engine',
				'current version',
				'valid (package)',
				'valid (dependency graph)',
			].map((x) => chalk.bold(chalk.gray(x))),
			...rows,
		]).trim(),
	];

	if (anyInvalid) {
		throw {
			code: EXITS.CURRENT,
			output,
=======
async function checkCurrent(engine, rootValids, graphValids) {
	const current = engine === 'node' ? process.version : null;
	const currentValid = rootValids.concat(graphValids).includes(current);

	const message = `\nCurrent ${engine} version, ${chalk.blue(chalk.bold(current))}, is ${chalk.bold(currentValid ? chalk.greenBright('valid') : chalk.red('invalid'))}!`;
	if (currentValid) {
		return {
			output: [message],
>>>>>>> 40b0de5... wip
		};
	}
	return {
		output,
	};
}

<<<<<<< HEAD
=======
>>>>>>> 2fb4feb... wip with conflicts
>>>>>>> 9aa5bd5... wip with conflicts
>>>>>>> dd05eb2... wip with conflicts
function isSubset(inner, outer) {
	const outerS = new Set(outer);
	return inner.every((item) => outerS.has(item));
}
<<<<<<< HEAD

<<<<<<< HEAD
async function checkEngines(selectedEngines, rootEngines, rootValids, graphValids, graphRanges, shouldSave) {
	/* eslint no-throw-literal: 0 */

	const engineEntries = Object.entries(graphRanges).map(([engine, { displayRange }]) => [engine, displayRange]);
	const engines = fromEntries(engineEntries);

	const fixMessage = shouldSave
		? `\n\`${chalk.gray('ls-engines')}\` will automatically fix this, per the \`${chalk.gray('--save')}\` option, by adding the following to your \`${chalk.gray('package.json')}\`:`
		: `\nYou can fix this by running \`${chalk.bold(chalk.gray('ls-engines --save'))}\`, or by manually adding the following to your \`${chalk.gray('package.json')}\`:`;

	let allOmitted = true;
	let anyOmitted = false;
	let allStar = true;
	let anyStar = false;
	const same = [];
	const subset = [];
	selectedEngines.forEach((engine) => {
		const value = rootEngines[engine];
		if (typeof value === 'string') {
			allOmitted = false;
			if (value === '*') {
				anyStar = true;
			} else {
				allStar = false;
			}
		} else {
			anyOmitted = true;
		}
		if (rootValids[engine].length === graphValids[engine].length) {
			same.push(engine);
		} else if (isSubset(rootValids[engine], graphValids[engine])) {
			subset.push(engine);
		}
	});

	let message;
	if (allOmitted) {
		message = '\nYour “engines” field is missing! Prefer explicitly setting a supported engine range.';
	} else if (anyOmitted) {
		message = '\nYour “engines” field has some of your selected engines missing! Prefer explicitly setting a supported engine range.';
	} else if (allStar) {
		message = '\nYour “engines” field has your selected engines set to `*`! Prefer explicitly setting a supported engine range.';
	} else if (anyStar) {
		message = '\nYour “engines” field has some of your selected engines set to `*`! Prefer explicitly setting a supported engine range.';
	}
	if (message) {
		throw {
			code: EXITS.IMPLICIT,
			output: [
				chalk.bold(chalk.red(message)),
				fixMessage,
				chalk.blue(`"engines": ${JSON.stringify(engines, null, 2)}`),
			],
			save(pkg) {
				/* eslint no-param-reassign: 0 */
				pkg.engines = { ...pkg.engines, ...engines };
=======
=======
<<<<<<< HEAD
>>>>>>> dd05eb2... wip with conflicts
async function checkEngines(rootNode, rootValids, graphValids, displayRange, shouldSave) {
=======

async function checkEngines(engine, rootEngine, rootValids, graphValids, displayRange, shouldSave) {
>>>>>>> 9aa5bd5... wip with conflicts
	const fixMessage = shouldSave
		? `\n\`${chalk.gray('ls-engines')}\` will automatically fix this, per the \`${chalk.gray('--save')}\` option, by adding the following to your \`${chalk.gray('package.json')}\`:`
		: `\nYou can fix this by running \`${chalk.bold(chalk.gray('ls-engines --save'))}\`, or by manually adding the following to your \`${chalk.gray('package.json')}\`:`;
	/* eslint no-throw-literal: 0 */
	if (rootEngine === '*') {
		throw {
			code: EXITS.IMPLICIT,
			output: [
				chalk.bold(chalk.red(`\nYour “engines” field is either missing, or set to \`{ "${engine}": "*" }\`! Prefer explicitly setting a supported engine range.`)),
				fixMessage,
				chalk.blue(`"engines": ${JSON.stringify({ [engine]: displayRange }, null, 2)}`),
			],
			save(pkg) {
				/* eslint no-param-reassign: 0 */
				if (!pkg.engines) {
					pkg.engines = {};
				}
				pkg.engines[engine] = displayRange;
>>>>>>> 433290c... wip with conflicts
			},
		};
	}

	if (same.length === selectedEngines.length) {
		return {
			output: [
				chalk.bold(chalk.green('\nYour “engines” field exactly matches your dependency graph’s requirements!')),
			],
		};
	}
	if (subset.length > 0) {
		const expandMessage = shouldSave
			? `\n\`${chalk.gray('ls-engines')}\` will automatically widen your support, per the \`${chalk.gray('--save')}\` option, by adding the following to your \`${chalk.gray('package.json')}\`:`
			: `\nIf you want to widen your support, you can run \`${chalk.bold(chalk.gray('ls-engines --save'))}\`, or manually add the following to your \`${chalk.gray('package.json')}\`:`;
		return {
			output: [
				chalk.bold(chalk.green(`\nYour “engines” field allows fewer ${engine} versions than your dependency graph does.`)),
				expandMessage,
<<<<<<< HEAD
				chalk.blue(`"engines": ${JSON.stringify(engines, null, 2)}`),
			],
			save(pkg) {
				/* eslint no-param-reassign: 0 */
				pkg.engines = { ...pkg.engines, ...engines };
=======
				chalk.blue(`"engines": ${JSON.stringify({ [engine]: displayRange }, null, 2)}`),
			],
			save(pkg) {
				/* eslint no-param-reassign: 0 */
				if (!pkg.engines) {
					pkg.engines = {};
				}
				pkg.engines[engine] = displayRange;
>>>>>>> 433290c... wip with conflicts
			},
		};
	}
	throw {
		code: EXITS.INEXACT,
		output: [
			chalk.red('\nYour “engines” field does not exactly match your dependency graph‘s requirements!'),
			fixMessage,
<<<<<<< HEAD
			chalk.blue(`"engines": ${JSON.stringify(engines, null, 2)}`),
		],
		save(pkg) {
			/* eslint no-param-reassign: 0 */
			pkg.engines = { ...pkg.engines, ...engines };
=======
			chalk.blue(`"engines": ${JSON.stringify({ [engine]: displayRange }, null, 2)}`),
		],
		save(pkg) {
			/* eslint no-param-reassign: 0 */
			if (!pkg.engines) {
				pkg.engines = {};
			}
			pkg.engines[engine] = displayRange;
>>>>>>> 433290c... wip with conflicts
		},
	};
}
<<<<<<< HEAD

=======
<<<<<<< HEAD
=======

async function getNPMVersions() {
	return new Promise((resolve, reject) => {
		exec('npm show --json npm versions', (err, result) => {
			if (err) {
				reject(err);
			} else {
				resolve(JSON.parse(result));
			}
		});
	});
}

<<<<<<< HEAD
>>>>>>> f11ee5b... wip with conflicts
=======
>>>>>>> e3e9eee... npm
>>>>>>> c232fdf... npm
>>>>>>> 505d027... npm
async function validVersionsForEngines(engines) {
	const allVersions = await pAllVersions;
	const entries = Object.entries(allVersions);
	return fromEntries(entries.map(([
		engine,
		versions,
	]) => [
		engine,
		versions.filter((v) => Semver.satisfies(v, engines[engine] || '*')),
	]));
}

async function getGraphValids(graphEntries) {
	if (graphEntries.length === 0) {
<<<<<<< HEAD
		return validVersionsForEngines(fromEntries(validEngines.map((engine) => [engine, '*'])));
=======
		return validVersionsForEngines({ node: '*' });
=======
async function getVersions() {
	const entries = await Promise.all([
		selectedEngines.has('node') ? getNodeVersions().then((x) => ['node', x]) : null,
		selectedEngines.has('npm') ? getNPMVersions().then((x) => ['npm', x]) : null,
	]);
	return fromEntries(entries.filter(Boolean));
}

async function checkEngineVersions(engine, engineVersions, rootEngine, graph) {
	const rootValids = engineVersions.filter((v) => Semver.satisfies(v, rootEngine));
	const graphAllowed = graph.map(([n, { [engine]: engineVersion }]) => [
		n,
		engineVersions.filter((v) => Semver.satisfies(v, engineVersion)),
	]);
	const graphValids = graph.length > 0
		? intersect(graphAllowed.map(([, vs]) => (vs.length > 0 ? vs : null)).filter(Boolean))
		: rootEngine;
	graphValids.sort((a, b) => -Semver.compare(a, b));
	const validMajorRanges = graph.length > 0 ? graphValids.reduceRight((prev, v) => {
		prev = [].concat(prev); // eslint-disable-line no-param-reassign
		return Semver.satisfies(v, caret(prev[prev.length - 1])) ? prev : prev.concat(v);
	}).map(caret) : ['*'];
	const validRange = new Semver.Range(validMajorRanges.join(' || '));
	if (!graphValids.every((v) => validRange.test(v))) {
		throw new RangeError('please report this: ' + graphValids.join(',') + ' / ' + validRange);
>>>>>>> 40b0de5... wip
>>>>>>> 6989428... wip with conflicts
	}
	const graphAllowed = await Promise.all(graphEntries.map(([, engines]) => validVersionsForEngines(engines)));
	const mergedGraphEngines = graphAllowed.reduce((mergedEngines, engines) => {
		const entries = Object.entries(engines);
		entries.forEach(([engine, versions]) => {
			if (!Array.isArray(mergedEngines[engine])) {
				mergedEngines[engine] = []; // eslint-disable-line no-param-reassign
			}
			mergedEngines[engine].push(versions);
		});
		return mergedEngines;
	}, {});
	return fromEntries(Object.entries(mergedGraphEngines).map(([engine, versionArrays]) => {
		const intersection = intersect(versionArrays);
		return [engine, intersection.sort((a, b) => -Semver.compare(a, b))];
	}));
}

const pRootRanges = pPackage.then(async (pkg) => {
	const engineEntries = validEngines.map((engine) => [
		engine,
		(pkg.data.engines && pkg.data.engines[engine]) || null,
	]).map(([engine, data]) => [engine, data && data.replace(/=(\d)/, '= $1')]);
	const engines = fromEntries(engineEntries);
	const rangeEntries = engineEntries.map(([engine, v]) => [engine, new Semver.Range(v || '*')]);
	const ranges = fromEntries(rangeEntries);
	const valids = await validVersionsForEngines(engines);
	return { engines, ranges, valids };
});

function dropPatch(v) {
	const num = v.replace(/^v/, '');
	return `^${Semver.major(num)}.${Semver.minor(num)}`;
}

const pGraphRanges = pGraphEntries.then(async (graphEntries) => {
	const graphValids = await getGraphValids(graphEntries);
	const graphRanges = Object.entries(graphValids).map(([engine, versions]) => {
		const validMajorRanges = graphEntries.length > 0 && versions.length > 0 ? versions.reduceRight((prev, v) => {
			if (prev.length === 0) {
				return [v];
			}
			return Semver.satisfies(v, caret(prev[prev.length - 1])) ? prev : prev.concat(v);
		}, []).map(dropPatch).reverse() : ['*'];
		const lastMajor = validMajorRanges[validMajorRanges.length - 1];
		const greaterThanLowest = lastMajor === '*' ? lastMajor : `>= ${lastMajor.replace(/^\^/, '')}`;
		const validRange = versions.every((v) => Semver.satisfies(v, greaterThanLowest))
			? new Semver.Range(greaterThanLowest)
			: new Semver.Range(validMajorRanges.join(' || '));
		if (!versions.every((v) => validRange.test(v))) {
			throw new RangeError(`please report this: ${engine}: ${versions.join(',')} / ${validRange}`);
		}

		const displayRange = validRange.raw && validRange.raw.replace(/(\.0)+( |$)/g, '$2').split(' ').join(' ');
		const tuple = [engine, { displayRange, validRange }];
		return tuple;
	});

	const engineEntries = graphRanges.map(([engine, { displayRange }]) => [engine, displayRange]);

	const engines = fromEntries(engineEntries);

	const validEntries = await Promise.all(validEngines.map(async (engine) => {
		const validForEngine = await validVersionsForEngines(engines);
		return [engine, validForEngine[engine]];
	}));
	const valids = fromEntries(validEntries);

	return {
		engines,
		ranges: fromEntries(graphRanges),
		valids,
	};
});

const pLatestEngineMajors = Promise.all([
	pRootRanges,
	pGraphRanges,
	pAllVersions,
]).then(([
	{ ranges: rootRanges },
	{ ranges: graphRanges },
	allVersions,
]) => getLatestEngineMajors(validEngines, allVersions, rootRanges, graphRanges));

function wrapCommaSeparated(array, limit) {
	const str = array.join(', ');
	if (str.length <= limit) {
		return str;
	}

	const re = new RegExp(`.{1,${limit}}(?<=(?:,|$)) `, 'g');
	return (str.match(re) || []).map((x) => x).join('\n');
}

const majorsHeading = 'Currently available latest release of each valid major version:';

function normalizeEngines(engines) {
	const entries = Object.entries(engines).map(([engine, version]) => [engine, version || '*']);
	return fromEntries(entries);
}

const pSummary = Promise.all([
	pRootRanges,
	pGraphRanges,
	pLatestEngineMajors,
]).then(([
	{ engines: rootEngines },
	{ engines: graphEngines },
	latestEngineMajors,
]) => ({
	output: [
		table([
			[
				'engine',
				majorsHeading,
			].map((x) => chalk.bold(chalk.gray(x))),
			...Object.entries(latestEngineMajors)
				.filter(([engine]) => selectedEngines.includes(engine))
				.map(([
					engine,
					{ root, graph },
				]) => [
					chalk.blue(engine),
					wrapCommaSeparated(intersect([root, graph]), majorsHeading.length),
				]),
		]),
		table([
			[
				'package engines:',
				'dependency graph engines:',
			].map((x) => chalk.bold(chalk.gray(x))),
			[
				`"engines": ${JSON.stringify(normalizeEngines(rootEngines), null, 2)}`,
				`"engines": ${JSON.stringify(normalizeEngines(graphEngines), null, 2)}`,
			].map((x) => chalk.blue(x)),
		]),
	],
}));

Promise.all([
	pGraphRanges,
	pPackage,
	pRootRanges,
]).then(async ([
	graphRanges,
	pkg,
	{ engines: rootEngines, valids: rootValids },
]) => {
<<<<<<< HEAD
	const { valids: graphValids, ranges: graphDisplayRanges } = graphRanges;
	const pEngines = checkEngines(selectedEngines, rootEngines, rootValids, graphValids, graphDisplayRanges, save);
=======
	const { valids: graphValids, ranges: { node: { displayRange } } } = graphRanges;
	const pEngines = checkEngines(rootEngines.node, rootValids, graphValids, displayRange, save);
<<<<<<< HEAD

	const pCurrent = current ? checkCurrent(selectedEngines, rootValids, graphValids) : { output: [] };
>>>>>>> 433290c... wip with conflicts

=======
<<<<<<< HEAD
	const pCurrent = current ? checkCurrent(selectedEngines, rootValids, graphValids) : { output: [] };
=======
=======
	const displayRange = validRange.raw && validRange.raw.replace(/(\.0)+( |$)/g, '$2').split(' ').join(' ');
	if (validRange.raw) {
		console.log(chalk.gray(`\nValid ${engine} version range: ${displayRange}`));
		const versionsByMajor = engineVersions.reduce((map, v) => {
			const major = Semver.major(v);
			const key = major === 0 ? `${major}.${Semver.minor(v)}` : major;
			if (!map[key]) {
				map[key] = [];
			}
			map[key].push(v);
			return map;
		}, {});
		const latestMajors = Object.values(versionsByMajor)
			.map((vs) => Semver.maxSatisfying(vs, validRange))
			.filter(Boolean)
			.sort(Semver.compare)
			.reverse();
		console.log(chalk.bold(chalk.gray(`\nCurrently available latest releases of each valid ${engine} major version: ${latestMajors.join(', ')}`)));
	}

	return [engine, {
		displayRange,
		graphValids,
		rootEngine,
		rootValids,
	}];
}

	const pCurrent = current ? checkCurrent(selectedEngines, rootValids, graphValids) : { output: [] };
=======
async function getEngineResults(engines, versions, rootVersions, graph) {
	const engineVersionResults = Array.from(
		engines,
		(engine) => checkEngineVersions(engine, versions[engine], rootVersions[engine], graph),
	);
	return fromEntries(await Promise.all(engineVersionResults));
}\

<<<<<<< HEAD
>>>>>>> 9aa5bd5... wip with conflicts
>>>>>>> dd05eb2... wip with conflicts
	// print out successes first
	const results = await allSettled([pSummary, pEngines, pCurrent]);
	const fulfilleds = results.filter((result) => result.status === 'fulfilled');
	const rejecteds = results.filter((result) => result.status === 'rejected');
	fulfilleds.forEach(({ value: { output } }) => {
		output.forEach((line) => {
			console.log(line);
=======
Promise.all([getVersions(), graphRanges, pPackage]).then(async ([versions, graph, pkg]) => {
	const rootVersions = {
		node: (pkg.data.engines && pkg.data.engines.node) || '*',
		npm: (pkg.data.engines && pkg.data.engines.npm) || '*',
	};

	return {
		engineResults: getEngineResults(selectedEngines, versions, rootVersions, graph),
		pkg,
	};
}).then(async ({ engineResults, pkg }) => {

	Object.entries(engineResults).forEach(async ([engine, {
		displayRange,
		graphValids,
		rootEngine,
		rootValids,
	}]) => {
		const pEngines = checkEngines(engine, rootEngine, rootValids, graphValids, displayRange, save);

		const pCurrent = current ? checkCurrent(engine, rootValids, graphValids) : { output: [] };

		// print out successes first
		const results = await allSettled([pEngines, pCurrent]);

		results.filter(({ status }) => status === 'fulfilled').forEach(({ value: { output } }) => {
			output.forEach((line) => {
				console.log(line);
			});
>>>>>>> 40b0de5... wip
		});
<<<<<<< HEAD
	});
<<<<<<< HEAD

=======
=======

>>>>>>> 9aa5bd5... wip with conflicts
>>>>>>> dd05eb2... wip with conflicts
	// print out failures last
	await rejecteds.reduce(async (prev, error) => {
		await prev;

		if (!error || !error.reason) {
			throw error;
		}
		const { reason } = error;
		// @ts-ignore
		const { code, output, save: doSave } = reason;
		if (!output) {
			throw reason;
		}

		if (save && doSave) {
			doSave(pkg.data);
			try {
				await pkg.save();
			} catch {
				process.exitCode |= EXITS.SAVE;
			}
		} else {
			process.exitCode |= code;
		}
		output.forEach((line) => {
			console.error(line);
		});
	}, Promise.resolve());
}).catch((e) => {
	console.error((e && e.stack) || e);
	process.exitCode |= EXITS.ERROR;
});
// # sourceMappingURL=ls-engines.js.map
